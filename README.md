- **Binary Tree Postorder Traversal (145)**
	- 要求不用递归实现后序遍历
	- 后序是left-right-root，那么首先用修正的前序root-right-left，然后reverse一下，变成left-right-root就行了，代码如下：

- **Factorial Trailing Zeroes(172)**
	- 给出整数n，求$n!$末尾的0的个数，要求在logarithmic时间内求解
	- 首先容易知道要出现0，只有$2 \times 5 =10$才行，而对于从$1,2,...,n$的这一系列的数，是2的倍数的数明显比5多，因此每一个5一定能找到一个2与之配对，换句话说，0的个数和5的个数一样多，下面只需要找出5的个数就行了，容易知道反复除以5就行，代码如下：

- **Container with most water(11)**
	- 给出一些列的隔板的高度，求问用哪两个隔板装水能装最多的水
	- 求解非常巧妙，左右分别向中间靠拢，指针记为left和right, 如果left的值比right的小，则left往中间移动一格，否则right往中间移动一格

- **Maximal Rectangle(85)**
	- 题目的要求是给出一个0-1矩阵，要求给出一个最大的矩形，使得矩形里面的所有值为1
	- 解法非常巧妙，从上往下扫描，维护三个数组**height**, **left**, **right**，分别存储每一列的信息，当迭代到第i行的时候，left表示从左往右最靠右的0的位置，初始为0；right表示从右往左最靠左的0的位置，初始为cLen+1，因此列的编码是(0, 1, 2, ..., cLen, cLen+1)，然后height存的就是当前单元从上往下连续的1的个数
	- 维护好了这些信息，那么每个单元格的面积就是
$$Area(j) = height(j)*(right(j) - left(j) - 1)$$
	- 值得注意的是，在更新left和right的时候，得查看上一迭代的时候height的值，如果是0，那么本层不受约束，如果是1，那么考虑到上下直接的连通，left的值不能小于旧的left值，right的值不能大于旧的right值

- **Regular Expression Matching(10)**
	- 这题难度比较大，就是普通的正则表达式匹配问题，即`*`和`.`，前者表示`*`前面的字符出现任意次，后者可以替代任何字符。
	- 用动态规划的思路做，设一个二维矩阵b[m+1][n+1]，其中m是string串的长度，n是pattern串的长度，然后b[i+1][j+1]代表的意义就是s[1..i]和p[1..j]是否能匹配上
	- 有了上述的约定，首先置b[0][0]=true，然后再初始化第一行和第一第二列，接着利用递推关系进行求解。详细的递推请参考这儿[猛戳我](http://xiaohuiliucuriosity.blogspot.com/2014/12/regular-expression-matching.html)

- **Wildcard Matching(44)**
	- 这题相对于上面的正则匹配容易很多，只是通配符`*`和`?`匹配，但是leetcode平台对这题进行了专门的限制，最后给出了一个超长的测例，最终会RunTime Error。因此需要一种改进的贪心算法，非常高效，大致思想是如果遇到了`*`，那么先暂时记录位置，只使用一次，如果发现不行就再多使用一次

- **Binary Search Tree Iterator(173)**
	- 题目意思非常清楚，在O(1)的**平均**时间复杂度和O(h)的空间复杂度下从小到大输出一个二叉查找树
	- 这题的难点就在于要求O(h)的空间复杂度，因为直接能想到的方法是利用递归算法中序遍历一棵二叉查找树，并且用一个queue存起来。然后再依次输出，但是这样的空间复杂度是O(n)，不符合要求，因此需要另谋出路
	- 一种方法是维护两个栈path和aux，其中aux记录当前深度搜索过程中的所有节点。当要求输出下一个的元素的时候，只需要进入一个循环，循环内部每次从path中取出一个节点current，和aux的`top()`节点比，如果不相等，说明还没有到树的末端，于是依次把current的右节点，current本身和current的左节点压入path, 同时需要把current本身压入aux，表示current节点是当前深度优先搜索路径上的点。接着如果两个栈的`top()`元素相等，那好办，两个都弹出顶端节点，然后返回其值。
	- 另一种更加省空间的方法是，维护一个栈path，并且定义一个`pushAll`的函数，该函数的功能是把给定节点的所有左节点压入path。每次要求输出下一个节点的时候，取出path顶端的节点current，然后把调用`pushAll(current.right)`，并且返回current.val。
	- 以上两种方法，经过测试发现第二种更快，需要32ms，第二种仅仅需要31ms

- **Intersection of Two Linked Lists(160)**
	- 题目是在一个Y型的链表中，已知两个头指针的位置，问交汇的地方在哪儿，如果没有交汇点，则返回NULL，并且在程序返回的时候不能改变链表的结构，时间复杂度要求$O(n)$，空间复杂度要求$O(1)$
	- 这题虽然是easy题，但是思路非常难想到，一般都会想着如何标记信息，但是这题恰恰把这一条路给堵死。其实仔细想想，如果想要两个点相遇，只需要走的长度一样就行，这样我们就可以让首先达到终点的指针从**另一条链**从头开始，后到达的指针也从另一条链开始，这样两个指针将会同时到达交汇点

- **Implement strStr() (28)**
	- 题目要求给定两个字符串haystack和needle，找出haystack中第一次匹配上needle的下标，如果不存在，则直接返回-1
	- 这道题可以直接进行线性搜索，当needle的某一次匹配不成功的时候，需要回退到匹配上第一个字符时候的下标，并且加1重新开始匹配needle。直到达到末尾，或者匹配成功

- **Path Sum II(113)**
	- 这题其实题意就是找出所有从根节点到叶子节点的路径，使得路径上的节点值的和为给定的值。题目本来并不难，只需要深度优先遍历即可，但是坑就坑在有负值，因此一开始本来用栈+剪枝的方法，后来发现不好使，各种bug，还是乖乖用递归解决。

- **Word Ladder(127)**
	- 这题非常有趣，给出start word和end word，以及一个字典，要求每次变换一个字符，使得start word能转变成end word，并且变换中间的word都必须在字典中。这个最暴力的方法就是首先构造一个图，节点是合法的word，边是edit distance正好为1。然后在图上使用BFS就行了。但是这样容易LTE，因此思路需要转变
	- 一种可行的方法是从start word角度出发，对所有的可能做遍历，然后用字典进行筛选剪枝，每当发现一种合法的变换(必然是字典中的word)，那么立即把新word从字典中删除，并且push进队列。如此循环，直到到达end word。

- **Permutations I(46)**
	- 生成全排列，并且没有重复元素。这个比较好办，可以使用递归式，即
	$$P(a_1,...,a_n)=\{a_1, P(a_2,...,a_n)\} \cup ... \cup \{a_n, P(a_1,..., a_{n-1} \}$$
	- 设计函数`void recursion(int []num, int n, int len)`，其中n为遍历的位置，如果`n==len-1`，函数返回

- **Permutations II(47)**
	- 这题允许集合中出现重复，因此主要任务是如何去重。容易知道假设目前待交换的位置为`i`，并且此时正在`i<=j <=len-1`中对`j`进行遍历。在46题中，直接交换`num[i]`和`num[j]`是没有任何问题的，因为没有重复，但是在本题中首先如果`num[i]==num[j]`，则必然会产生重复；除此以外，如果存在`i<=k<=j-1`使得`num[k] == num[j]`，那么说明在遍历到`j`之前已经替换过和`num[j]`相等的`num[k]`了，这个时候也会产生重复。
	- 综上知道，只需要保证在`i<=k<=j-1`中没有元素满足`num[k]==num[j]`即可
